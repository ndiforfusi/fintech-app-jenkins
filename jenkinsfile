pipeline {
  agent { label 'maven-sonarqube' } // SSH build node with instance profile

  tools {maven 'maven-3-9-11'}

  parameters {
    choice(name: 'ENVIRONMENT', choices: ['dev', 'qa', 'uat', 'prod'], description: 'Deployment Environment')
    string(name: 'IMAGE_TAG', defaultValue: '', description: 'Docker Image Tag (leave empty to auto-generate timestamp)')
    string(name: 'REGION', defaultValue: 'us-west-2', description: 'AWS Region')
    string(name: 'ECR_REPO', defaultValue: 'fintech-app', description: 'ECR repository name')
  }

  environment {
    AWS_REGION = "${params.REGION}"
  }

  options {
    disableConcurrentBuilds()
    timestamps()
    ansiColor('xterm')
    buildDiscarder(logRotator(numToKeepStr: '30', artifactNumToKeepStr: '30'))
    timeout(time: 60, unit: 'MINUTES')
  }

  stages {

    stage('Checkout') {
      steps {
        checkout scm
        echo "Branch: ${env.BRANCH_NAME ?: 'N/A'} | PR: ${env.CHANGE_ID ?: 'no'}"
      }
    }

    stage('Tooling Setup') {
      steps {
        sh """
          set -xe
          java -version || true
          mvn -version || true
          docker --version
          aws --version || true
          kubectl version --client=true --short=true || true
        """
      }
    }

    stage('Build with Maven') {
      steps {
        sh '''
          set -e
          [ -f /etc/profile.d/maven.sh ] && . /etc/profile.d/maven.sh || true
          mvn -B -ntp clean package -DskipTests
        '''
        archiveArtifacts artifacts: 'target/**/*.jar', fingerprint: true, onlyIfSuccessful: true
      }
    }

    stage('SonarQube Scan') {
      when { expression { return !env.CHANGE_ID } }
      environment {
        SONAR_HOST_URL = credentials('SONAR_HOST_URL')
        SONAR_TOKEN    = credentials('SONAR_TOKEN')
      }
      steps {
        sh '''
          set -e
          mvn -B -ntp sonar:sonar \
            -Dsonar.host.url="$SONAR_HOST_URL" \
            -Dsonar.login="$SONAR_TOKEN" \
            -Dsonar.projectKey=fintech-app-jenkins \
            -Dsonar.projectName='fintech-app-jenkins' \
            -Dsonar.sources=. \
            -Dsonar.java.binaries=target/classes
        '''
      }
    }

    stage('AWS Identity (Instance Profile)') {
      steps {
        sh 'aws sts get-caller-identity'
      }
    }

    stage('Resolve AWS Account ID') {
      steps {
        script {
          def acct = sh(script: 'aws sts get-caller-identity --query Account --output text', returnStdout: true).trim()
          if (!acct || !(acct ==~ /^[0-9]{12}$/)) {
            error "Could not resolve valid AWS Account ID from instance profile"
          }
          env.RESOLVED_ACCOUNT_ID = acct
          echo "Resolved AWS Account ID: ${env.RESOLVED_ACCOUNT_ID}"
        }
      }
    }

    stage('Determine Image Tag') {
      steps {
        script {
          def ts = new Date().format('yyyyMMddHHmmss', TimeZone.getTimeZone('UTC'))
          env.EFFECTIVE_IMAGE_TAG = params.IMAGE_TAG?.trim() ? params.IMAGE_TAG.trim() : ts
          echo "Using image tag: ${env.EFFECTIVE_IMAGE_TAG}"
        }
      }
    }

    stage('Login to ECR') {
      steps {
        sh """
          set -e
          aws ecr get-login-password --region ${params.REGION} | \
            docker login --username AWS --password-stdin ${env.RESOLVED_ACCOUNT_ID}.dkr.ecr.${params.REGION}.amazonaws.com
        """
      }
    }

    stage('Build & Push Docker Image') {
      steps {
        script {
          def imageUri = "${env.RESOLVED_ACCOUNT_ID}.dkr.ecr.${params.REGION}.amazonaws.com/${params.ECR_REPO}:${env.EFFECTIVE_IMAGE_TAG}"
          echo "Building ${imageUri}"
          sh """
            set -e
            docker build -t ${imageUri} .
            docker push ${imageUri}
          """
          env.IMAGE_URI = imageUri
        }
      }
    }

    stage('Deploy Gate') {
      when {
        allOf {
          expression { return !env.CHANGE_ID }
          anyOf { branch 'main'; branch 'release' }
        }
      }
      steps {
        script {
          timeout(time: 20, unit: 'MINUTES') {
            input message: "Approve deploy of ${env.IMAGE_URI} to ${params.ENVIRONMENT}?", ok: 'Deploy'
          }
        }
      }
    }

    stage('Deploy to EKS') {
      when {
        allOf {
          expression { return !env.CHANGE_ID }
          anyOf { branch 'main'; branch 'release' }
        }
      }
      steps {
        sh """
          set -euo pipefail

          CLUSTER_NAME="${params.ENVIRONMENT}-dominion-cluster"
          aws eks update-kubeconfig --region ${params.REGION} --name "$CLUSTER_NAME"

          kubectl get nodes

          # Optional addons
          [ -x eks_addons/script/helm_install.sh ] && eks_addons/script/helm_install.sh || true
          [ -x eks_addons/script/helm_charts.sh ]  && eks_addons/script/helm_charts.sh  || true

          # Monitoring/logging
          [ -d ./eks_addons/monitoring ] && kubectl apply -k ./eks_addons/monitoring || true
          [ -d ./eks_addons/elk ]        && kubectl apply -k ./eks_addons/elk        || true

          ENV="${params.ENVIRONMENT}"
          IMAGE_URI="${env.IMAGE_URI}"

          FILE=""
          for p in "./k8s/overlays/$ENV/patch-deployment.yaml" \\
                   "./fintech-app/k8s/overlays/$ENV/patch-deployment.yaml" \\
                   "/fintech-app/k8s/overlays/$ENV/patch-deployment.yaml"; do
            if [ -f "$p" ]; then FILE="$p"; break; fi
          done

          if [ -z "$FILE" ]; then
            echo "ERROR: patch-deployment.yaml not found for ENV=$ENV" >&2
            exit 1
          fi

          echo "Patching $FILE with image: $IMAGE_URI"
          perl -0777 -pe "s|image:\\s*[\\w\\.\\-]+\\.dkr\\.ecr\\.[\\w-]+\\.amazonaws\\.com/[\\w\\.\\-]+:[\\w\\.\\-]+|image: $IMAGE_URI|g" -i "$FILE"

          echo "Updated image line:"
          grep -nE 'image:\\s' "$FILE" | head -1

          OVERLAY_DIR=""
          for d in "./k8s/overlays/$ENV" "./fintech-app/k8s/overlays/$ENV" "/fintech-app/k8s/overlays/$ENV"; do
            if [ -d "$d" ]; then OVERLAY_DIR="$d"; break; fi
          done

          if [ -z "$OVERLAY_DIR" ]; then
            echo "ERROR: Overlay directory for ENV=$ENV not found" >&2
            exit 1
          fi

          echo "Applying overlay: $OVERLAY_DIR"
          kubectl apply -k "$OVERLAY_DIR"
        """
      }
    }
  }

  post {
    always {
      sh '''
        set +e
        docker image prune -af --filter "until=24h" || true
        docker container prune -f || true
        docker volume prune -f || true
      '''
      cleanWs(deleteDirs: true, notFailBuild: true)
    }
  }
}
