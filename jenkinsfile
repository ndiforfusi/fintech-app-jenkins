pipeline {
  agent { label 'maven-sonarqube' }

  tools { maven 'maven-3-9-11' }

  parameters {
    choice(
      name: 'ENVIRONMENT',
      choices: ['prod', 'qa', 'uat', 'dev'],
      description: 'Deployment Environment'
    )

    string(
      name: 'IMAGE_TAG',
      defaultValue: '',
      description: 'Docker Image Tag (leave empty to auto-generate timestamp)'
    )

    string(
      name: 'REGION',
      defaultValue: 'us-west-2',
      description: 'AWS Region'
    )

    string(
      name: 'ECR_REPO',
      defaultValue: 'fintech-app',
      description: 'ECR repository name'
    )

    string(
      name: 'ASSUME_ROLE_ARN',
      defaultValue: '',
      description: 'Optional: STS role ARN to assume for ECR'
    )

    string(
      name: 'K8S_NAMESPACE',
      defaultValue: 'fintech',
      description: 'Kubernetes namespace to deploy into'
    )

    string(
      name: 'KUBECONFIG_CREDENTIAL_ID',
      defaultValue: 'kubeconfig-fintech-nonprod',
      description: 'Jenkins Secret File credential ID holding kubeconfig'
    )
  }

  environment {
    AWS_REGION = "${params.REGION}"
    KUBECONFIG = "${WORKSPACE}/.kube/config"
  }

  options {
    disableConcurrentBuilds()
    timestamps()
    ansiColor('xterm')
    buildDiscarder(logRotator(numToKeepStr: '30', artifactNumToKeepStr: '30'))
    timeout(time: 60, unit: 'MINUTES')
  }

  stages {

    stage('Checkout') {
      steps {
        checkout scm
        echo "Branch: ${env.BRANCH_NAME ?: 'N/A'} | PR: ${env.CHANGE_ID ?: 'no'}"
      }
    }

    stage('Tooling Setup') {
      steps {
        sh """
          set -xe
          java -version || true
          mvn -version || true
          docker --version
          aws --version || true
          kubectl version --client=true --short=true || true
        """
      }
    }

    stage('Build with Maven') {
      steps {
        sh '''
          set -e
          [ -f /etc/profile.d/maven.sh ] && . /etc/profile.d/maven.sh || true
          mvn -B -ntp clean package -DskipTests
        '''
        archiveArtifacts artifacts: 'target/**/*.jar', fingerprint: true, onlyIfSuccessful: true
      }
    }

    stage('SonarQube Scan') {
      when { expression { return !env.CHANGE_ID } }
      environment {
        SONAR_HOST_URL = credentials('SONAR_HOST_URL')
        SONAR_TOKEN    = credentials('SONAR_TOKEN')
      }
      steps {
        sh '''
          set -e
          mvn -B -ntp sonar:sonar \
            -Dsonar.host.url="$SONAR_HOST_URL" \
            -Dsonar.login="$SONAR_TOKEN" \
            -Dsonar.projectKey=fintech-app \
            -Dsonar.projectName='fintech-app' \
            -Dsonar.sources=. \
            -Dsonar.java.binaries=target/classes
        '''
      }
    }

    stage('Base AWS Identity (Instance Profile)') {
      steps {
        sh '''
          set -e
          echo "Base AWS identity (before optional assume-role):"
          aws sts get-caller-identity || echo "No instance profile / AWS identity"
        '''
      }
    }

    stage('Assume AWS Role for ECR (Optional)') {
      when { expression { return params.ASSUME_ROLE_ARN?.trim() } }
      steps {
        script {
          echo "Assuming deploy role for ECR: ${params.ASSUME_ROLE_ARN}"

          def json = sh(
            script: """
              set -e
              aws sts assume-role \
                --role-arn '${params.ASSUME_ROLE_ARN}' \
                --role-session-name 'jenkins-ecr-${params.ENVIRONMENT}' \
                --query 'Credentials' \
                --output json
            """,
            returnStdout: true
          ).trim()

          def creds = readJSON(text: json)
          env.AWS_ACCESS_KEY_ID     = creds.AccessKeyId
          env.AWS_SECRET_ACCESS_KEY = creds.SecretAccessKey
          env.AWS_SESSION_TOKEN     = creds.SessionToken

          echo "Assumed role successfully."
        }
      }
    }

    stage('Resolved AWS Identity (Effective)') {
      steps {
        sh '''
          set -e
          echo "Effective AWS identity (after optional assume-role):"
          aws sts get-caller-identity || echo "No AWS identity configured"
        '''
      }
    }

    stage('Resolve AWS Account ID') {
      steps {
        script {
          def acct = sh(
            script: 'aws sts get-caller-identity --query Account --output text',
            returnStdout: true
          ).trim()

          if (!acct || !(acct ==~ /^[0-9]{12}$/)) {
            error "Could not resolve AWS Account ID"
          }

          env.RESOLVED_ACCOUNT_ID = acct
          echo "Resolved AWS Account ID: ${env.RESOLVED_ACCOUNT_ID}"
        }
      }
    }

    stage('Determine Image Tag') {
      steps {
        script {
          def ts = new Date().format('yyyyMMddHHmmss', TimeZone.getTimeZone('UTC'))
          env.EFFECTIVE_IMAGE_TAG = params.IMAGE_TAG?.trim() ? params.IMAGE_TAG.trim() : ts
          echo "Using image tag: ${env.EFFECTIVE_IMAGE_TAG}"
        }
      }
    }

    stage('Login to ECR') {
      steps {
        sh """
          set -e
          aws ecr get-login-password --region ${params.REGION} | \
            docker login --username AWS --password-stdin \
            ${env.RESOLVED_ACCOUNT_ID}.dkr.ecr.${params.REGION}.amazonaws.com
        """
      }
    }

    stage('Build & Push Docker Image') {
      steps {
        script {
          def imageUri =
            "${env.RESOLVED_ACCOUNT_ID}.dkr.ecr.${params.REGION}.amazonaws.com/${params.ECR_REPO}:${env.EFFECTIVE_IMAGE_TAG}"

          echo "Building ${imageUri}"

          sh """
            set -e
            docker build -t ${imageUri} .
            docker push ${imageUri}
          """

          env.IMAGE_URI = imageUri
        }
      }
    }

    stage('Load kubeconfig from Jenkins Credential') {
      steps {
        withCredentials([file(credentialsId: "${params.KUBECONFIG_CREDENTIAL_ID}", variable: 'KUBECONFIG_FILE')]) {
          sh '''
            set -e
            echo "Preparing workspace-scoped kubeconfig..."
            mkdir -p "$(dirname "${KUBECONFIG}")"
            cp "${KUBECONFIG_FILE}" "${KUBECONFIG}"
            chmod 600 "${KUBECONFIG}"

            kubectl config get-contexts || {
              echo "WARN: Could not list contexts"
            }
          '''
        }
      }
    }

    stage('Deploy to Kubernetes (kubeconfig file)') {
      steps {
        withEnv([
          "ENV=${params.ENVIRONMENT}",
          "IMAGE_URI=${env.IMAGE_URI}",
          "K8S_NAMESPACE=${params.K8S_NAMESPACE}"
        ]) {
          sh '''
            set -eu

            echo "Testing Kubernetes connectivity..."
            kubectl cluster-info || {
              echo "ERROR: Unable to reach Kubernetes API"
              exit 1
            }

            kubectl get nodes

            FILE=""
            for p in \
              "./k8s/overlays/$ENV/patch-deployment.yaml" \
              "./fintech-app/k8s/overlays/$ENV/patch-deployment.yaml" \
              "/fintech-app/k8s/overlays/$ENV/patch-deployment.yaml"
            do
              if [ -f "$p" ]; then
                FILE="$p"
                break
              fi
            done

            if [ -z "$FILE" ]; then
              echo "ERROR: patch-deployment.yaml not found for ENV=$ENV"
              exit 1
            fi

            echo "Patching deployment file: $FILE"
            perl -0777 -pe \
              "s|image:\\s*[\\w\\.\\-]+\\.dkr\\.ecr\\.[\\w-]+\\.amazonaws\\.com/[\\w\\.\\-]+:[\\w\\.\\-]+|image: $IMAGE_URI|g" \
              -i "$FILE"

            echo "Updated image:"
            grep -nE 'image:' "$FILE" | head -1 || true

            OVERLAY_DIR=""
            for d in \
              "./k8s/overlays/$ENV" \
              "./fintech-app/k8s/overlays/$ENV" \
              "/fintech-app/k8s/overlays/$ENV"
            do
              if [ -d "$d" ]; then
                OVERLAY_DIR="$d"
                break
              fi
            done

            if [ -z "$OVERLAY_DIR" ]; then
              echo "ERROR: Overlay directory not found for ENV=$ENV"
              exit 1
            fi

            echo "Applying overlay: $OVERLAY_DIR"
            kubectl apply -k "$OVERLAY_DIR" -n "$K8S_NAMESPACE"
          '''
        }
      }
    }
  }

  post {
    always {
      sh '''
        set +e
        docker image prune -af --filter "until=24h" || true
        docker container prune -f || true
        docker volume prune -f || true
        rm -rf .kube || true
      '''
      cleanWs(deleteDirs: true, notFailBuild: true)
    }
  }
}
